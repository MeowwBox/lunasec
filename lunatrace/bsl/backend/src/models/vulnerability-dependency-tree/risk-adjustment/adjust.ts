/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import cvss from 'cvss';
import minimatch from 'minimatch';

import { Analysis_Finding_Source_Enum, Analysis_Finding_Type_Enum } from '../../../hasura-api/generated';
import {
  Adjustment,
  FolderSettings,
  ManifestNode,
  PackageVulnerability,
  TriagedPackageVulnerability,
  VulnerableRelease,
} from '../types';

import { modifyVectorString, parseAdjustment } from './vector-strings';

// takes in a vulnerable release and the list of folder settings configured on the project, determines which to apply, if any, and adjusts the score
// this happens as a final pass over the vulnerable releases, because at that point the tree is fully built and the chains are populated
// This modifies the vulnerable releases in place rather than returning new objects
export function adjustRelease(vulnerableRelease: VulnerableRelease, folderSettings: FolderSettings): void {
  // get the root paths
  const resultLocations = vulnerableRelease.chains.flatMap((chain) => chain[0].locations);
  const firstPartyPaths = resultLocations.map((location) => location.path);
  // find a setting that matches all of the paths, starting with the highest precedence settings and ending with the root setting as thats the order it comes from hasura
  const matchingFolderSetting = folderSettings.find((setting) => {
    firstPartyPaths.every((path) => minimatch(path, setting.path_glob));
  });

  if (!matchingFolderSetting) {
    // nothing to do, bail
    return;
  }

  // go through each vulnerability and perform the adjustment.
  const vulnerabilities = vulnerableRelease.affected_by;
  vulnerabilities.forEach((vuln) => {
    adjustOneVulnerability(vuln, matchingFolderSetting);
  });
  // Add some helpful information to the overall release about what settings have been applied
  mergeVulnAdjustmentsOntoRelease(vulnerableRelease);
}

function mergeVulnAdjustmentsOntoRelease(vulnRelease: VulnerableRelease): void {
  vulnRelease.affected_by.forEach((vuln) => {
    if (vuln.adjustment) {
      const prexistingAdjustment = vulnRelease.adjustment;
      if (!prexistingAdjustment || vuln.adjustment.adjusted_cvss_score > prexistingAdjustment.adjusted_cvss_score) {
        vulnRelease.adjustment = vuln.adjustment;
      }
    }
  });
}

function adjustOneVulnerability(vuln: TriagedPackageVulnerability, setting: FolderSettings[number]): void {
  // While our database was designed to support multiple severities per vulnerability, in reality we only seem to have one per vuln
  const severityObject = vuln.vulnerability.severities[0];
  // handle only cvss v3, that's all we have in the DB at the time of writing
  if (!severityObject || severityObject.type !== 'CVSS_V3') {
    return;
  }
  const vectorString = severityObject.score;
  // parse each adjustment into an object of vector subcomponents like {CA:N,R:M,...}
  const adjustmentObjects = setting.folder_environmental_adjustments.map((adjustment) =>
    parseAdjustment(adjustment.cvss_environmental_adjustment)
  );
  // merge all of the adjustments onto the original vector string from the vulnerability
  const modifiedVector = adjustmentObjects.reduce<string>((vectorString, adjustmentObject) => {
    return modifyVectorString(vectorString, adjustmentObject);
  }, vectorString);

  const environmentalCvss = cvss.getEnvironmental(modifiedVector);

  const adjustmentNames = setting.folder_environmental_adjustments.map((a) => a.cvss_environmental_adjustment.name);
  // dont overwrite the main severity values, just add a new object of adjusted values so that the originals are preserved
  vuln.adjustment = {
    adjusted_cvss_score: environmentalCvss.score,
    adjusted_severity_name: environmentalCvss.rating,
    path_matched: setting.path_glob,
    adjustments_applied: adjustmentNames,
  };
  return;
}
